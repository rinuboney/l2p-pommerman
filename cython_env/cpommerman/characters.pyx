"""These are objects in the game world. Please do not edit this file. The competition will be run with it as is."""

cimport cython
cimport constants
cimport utility
from utility cimport Position, byte

cdef class Bomber(object):
    """Container to keep the agent state."""

    @staticmethod
    cdef Bomber new(byte agent_id=0, constants.GameType game_type=constants.GameType.FFA):
        cdef Bomber self = Bomber.__new__(Bomber)
        self._game_type = game_type
        self.ammo = 1
        self.is_alive = True
        self.blast_strength = constants.DEFAULT_BLAST_STRENGTH
        self.can_kick = False
        self.set_agent_id(agent_id)
        return self

    cdef void set_agent_id(self, byte agent_id):
        cdef byte teammate_id, id_, i
        self.agent_id = agent_id
        if self._game_type == constants.GameType.FFA:
            self.teammate = constants.Item.AgentDummy
            i = 0
            for id_ in range(4):
                if id_ != agent_id:
                    self.enemies[i] = utility.agent_value(id_)
                    i += 1
        else:
            teammate_id = (agent_id + 2) % 4
            i = 0
            for id_ in range(4):
                if id_ != agent_id and id_ != teammate_id:
                    self.enemies[i] = utility.agent_value(id_)
                    i += 1
            self.enemies[i] = constants.Item.AgentDummy

    cdef Bomb maybe_lay_bomb(self):
        if self.ammo > 0:
            self.ammo -= 1
            return Bomb.new(self, self.position, constants.DEFAULT_BOMB_LIFE,
                            self.blast_strength)
        return None

    cdef void incr_ammo(self):
        self.ammo += 1

    cdef Position get_next_position(self, constants.Action direction):
        return utility.get_next_position(self.position, direction)

    cdef void move(self, constants.Action direction):
        self.position = self.get_next_position(direction)

    cdef void stop(self):
        pass

    @cython.boundscheck(False)  # Deactivate bounds checking
    @cython.wraparound(False)   # Deactivate negative indexing.
    @cython.initializedcheck(False)   # Deactivate memoryview initialization check.
    cdef byte in_range(self, const byte[constants.BOARD_SIZE][constants.BOARD_SIZE] exploded_map):
        return exploded_map[self.position.row][self.position.col] == 1

    cdef void die(self):
        self.is_alive = False

    cdef void set_start_position(self, Position start_position):
        self.start_position = start_position

    cdef void reset(self, byte ammo=1, byte is_alive=True, byte blast_strength=constants.DEFAULT_BLAST_STRENGTH, byte can_kick=False):
        self.position = self.start_position
        self.ammo = ammo
        self.is_alive = is_alive
        self.blast_strength = blast_strength or constants.DEFAULT_BLAST_STRENGTH
        self.can_kick = can_kick

    cdef void pick_up(self, constants.Item item, byte max_blast_strength):
        if item == constants.Item.ExtraBomb:
            self.ammo = min(self.ammo + 1, 10)
        elif item == constants.Item.IncrRange:
            self.blast_strength = min(self.blast_strength + 1,
                                      max_blast_strength)
        elif item == constants.Item.Kick:
            self.can_kick = True

    cdef dict to_json(self):
        return {
            "agent_id": self.agent_id,
            "is_alive": bool(self.is_alive),
            "position": (self.position.row, self.position.col),
            "ammo": self.ammo,
            "blast_strength": self.blast_strength,
            "can_kick": bool(self.can_kick)
        }

    cdef void *encode(self, void *buf):
        buf = utility.encode(buf, &self._game_type, sizeof(self._game_type))
        buf = utility.encode(buf, &self.ammo, sizeof(self.ammo))
        buf = utility.encode(buf, &self.is_alive, sizeof(self.is_alive))
        buf = utility.encode(buf, &self.blast_strength, sizeof(self.blast_strength))
        buf = utility.encode(buf, &self.can_kick, sizeof(self.can_kick))
        buf = utility.encode(buf, &self.agent_id, sizeof(self.agent_id))
        buf = utility.encode(buf, &self.teammate, sizeof(self.teammate))
        buf = utility.encode(buf, &self.enemies, sizeof(self.enemies))
        buf = utility.encode(buf, &self.position, sizeof(self.position))
        buf = utility.encode(buf, &self.start_position, sizeof(self.start_position))
        return buf

    cdef const void *decode(self, const void *buf):
        buf = utility.decode(buf, &self._game_type, sizeof(self._game_type))
        buf = utility.decode(buf, &self.ammo, sizeof(self.ammo))
        buf = utility.decode(buf, &self.is_alive, sizeof(self.is_alive))
        buf = utility.decode(buf, &self.blast_strength, sizeof(self.blast_strength))
        buf = utility.decode(buf, &self.can_kick, sizeof(self.can_kick))
        buf = utility.decode(buf, &self.agent_id, sizeof(self.agent_id))
        buf = utility.decode(buf, &self.teammate, sizeof(self.teammate))
        buf = utility.decode(buf, &self.enemies, sizeof(self.enemies))
        buf = utility.decode(buf, &self.position, sizeof(self.position))
        buf = utility.decode(buf, &self.start_position, sizeof(self.start_position))
        return buf

cdef class Bomb(object):
    """Container for the Bomb object."""

    @staticmethod
    cdef Bomb new(Bomber bomber,
                  Position position,
                  byte life,
                  byte blast_strength,
                  constants.Action moving_direction=constants.Action.Stop):
        cdef Bomb self = Bomb.__new__(Bomb)
        self.bomber = bomber
        self.position = position
        self.life = life
        self.blast_strength = blast_strength
        self.moving_direction = moving_direction
        return self

    cdef void tick(Bomb self):
        self.life -= 1

    cdef void fire(Bomb self):
        """Encounter Flames and blow up."""
        self.life = 0

    cdef void move(Bomb self):
        if self.is_moving():
            self.position = utility.get_next_position(self.position,
                                                      self.moving_direction)

    cdef void stop(Bomb self):
        self.moving_direction = constants.Action.Stop

    cdef byte exploded(Bomb self):
        return self.life == 0

    cdef byte is_moving(Bomb self):
        return self.moving_direction != constants.Action.Stop

    cdef dict to_json(Bomb self):
        return {
            "position": (self.position.row, self.position.col),
            "bomber_id": self.bomber.agent_id,
            "life": self.life,
            "blast_strength": self.blast_strength,
            # for compatibility with original env
            "moving_direction": None if self.moving_direction == constants.Action.Stop else self.moving_direction
        }

    cdef void *encode(self, void *buf):
        buf = utility.encode(buf, &self.bomber.agent_id, sizeof(self.bomber.agent_id))
        buf = utility.encode(buf, &self.position, sizeof(self.position))
        buf = utility.encode(buf, &self.life, sizeof(self.life))
        buf = utility.encode(buf, &self.blast_strength, sizeof(self.blast_strength))
        buf = utility.encode(buf, &self.moving_direction, sizeof(self.moving_direction))
        return buf

    cdef const void *decode(self, const void *buf):
        # done outside of this function
        #buf = utility.encode(buf, &self.bomber.agent_id, sizeof(self.bomber.agent_id))
        buf = utility.decode(buf, &self.position, sizeof(self.position))
        buf = utility.decode(buf, &self.life, sizeof(self.life))
        buf = utility.decode(buf, &self.blast_strength, sizeof(self.blast_strength))
        buf = utility.decode(buf, &self.moving_direction, sizeof(self.moving_direction))
        return buf

cdef class Flame(object):
    """Container for Flame object."""

    @staticmethod
    cdef Flame new(Position position, byte life=2):
        cdef Flame self = Flame.__new__(Flame)
        self.position = position
        self._life = life
        return self

    cdef void tick(Flame self):
        self._life -= 1

    cdef byte is_dead(Flame self):
        return self._life == 0

    cdef dict to_json(Flame self):
        return {"position": (self.position.row, self.position.col), "life": self._life}

    cdef void *encode(self, void *buf):
        buf = utility.encode(buf, &self.position, sizeof(self.position))
        buf = utility.encode(buf, &self._life, sizeof(self._life))
        return buf

    cdef const void *decode(self, const void *buf):
        buf = utility.decode(buf, &self.position, sizeof(self.position))
        buf = utility.decode(buf, &self._life, sizeof(self._life))
        return buf
